#!/usr/bin/ruby
# Generates a template for exploit_config.h
# This script is heaviliy adapted for VHBL: it assumes that perfect syscalls are not available, and that hbl needs to be run in a "flat" folder
#
# Required input files are:
#
# 1) "memdump.bin", a user memory dump from PSPLink with 
# "savemem 0x08800000 0x01800000 memdump.bin"
#
# and from the same game session:
#
# 2) "uidlist.txt", which is the the output of the "uidlist"
# command in PSPLink
#
# 3) "sdk.S", from your exploit
#
# Initial code by JJS & wololo

# Copied from eLoaderconf.rb

# This 

class String
# Thanks to mon_Ouie for ruby 1.9 compatibility
  def to_a
    [self]
  end

  def hex_to_bin
    return gsub(/\s/,'').to_a.pack("H*")
  end
end

class Integer
    def mips(bytes)
        return to_s(16).rjust(bytes * 2, "0").hex_to_bin.reverse
    end
end     


fileEntry = Struct.new(:type, :uid, :name)
addresses = Array.new
currentHeader = nil
baseAddress = 0x08800000

uidlist = File.new("uidlist.txt", "r")
memdumpfile = File.new("memdump.bin", "r")
memdumpfile.binmode
memdump = memdumpfile.read


#[Fpl]    UID 0x00288E0D (attr 0x0 entry 0x88014470)
regexpHeader = /^\[(.+)\]    UID (0x.+) \(attr (0x.+) entry (0x.+)\)$/

#(UID): 0x048E3761, (entry): 0x882471b8, (size): 48, (attr): 0xFF, (Name): sgx-ao-evf
regexpEntry = /^\(UID\): (0x.+), \(entry\): (0x.+), \(size\): (.+), \(attr\): (0x.+), \(Name\): (.+)$/

while (line = uidlist.gets)
    line.chomp!
	if (line.match(regexpHeader)) 
		line.scan(regexpHeader) { |name, uid, attr, entry|
			currentHeader = name
		}
	end
	
	if (line.match(regexpEntry)) 
		line.scan(regexpEntry) { |uid, entry, size, attr, name|
			if attr == "0xFF"
				# skip thread stacks and the "main" thread which is unloaded with the module
				if (name.index("stack:") == nil) and not ((currentHeader == "Thread") and (name == "main"))
					addresses.push(fileEntry.new(currentHeader, uid, name))
				end
			end
		}
	end
end

currentHeader = nil

addressOutput = {
    "TH_ADDR_LIST"=>[], 
    "EV_ADDR_LIST"=>[], 
    "SEMA_ADDR_LIST"=>[],
    "GAME_FREEMEM_ADDR"=>[],    
}

addresses.each { |addressEntry|
	if addressEntry.type == "Thread"
		# the thread uid is right next to the thread stack
		index = memdump.index(addressEntry.uid.to_i(16).mips(4) + "FF".to_i(16).mips(1))
	else
		index = memdump.index(addressEntry.uid.to_i(16).mips(4))
	end
	
	if (index != nil)
		value = "0x0#{(index + baseAddress).to_s(16).upcase}"
			
        if addressEntry.type == "Thread"
            addressOutput["TH_ADDR_LIST"].push(value)
        elsif addressEntry.type == "EventFlag"
            addressOutput["EV_ADDR_LIST"].push(value)
        elsif addressEntry.type == "Semaphore"
            addressOutput["SEMA_ADDR_LIST"].push(value)
        elsif addressEntry.type == "SceSysMemMemoryBlock"
            addressOutput["GAME_FREEMEM_ADDR"].push(value)
        end
	end
}


hooks = Array.new;
nids = Hash.new;
sdk = File.new("sdk.S", "r")

#	AddNID sceIoLseek, 0x08A885D0
regexpNID = /^\sAddNID (.+), (.+)$/
while (line = sdk.gets)
    line.chomp!
	if (line.match(regexpNID)) 
		line.scan(regexpNID) { |name, addr|
			nids[name] = addr;
		}
	end
end

#Defines a bunch of common hooks

if (!nids["sceKernelDcacheWritebackInvalidateAll"]) 
    if (nids["sceKernelDcacheWritebackAll"])
        hooks.push(
"// define if your exploit does not have access to sceKernelDcacheWritebackInvalidateAll
#undef CLEAR_CACHE
#define CLEAR_CACHE sceKernelDcacheWritebackAll()
#define HOOK_sceKernelDcacheWritebackInvalidateAll_WITH_sceKernelDcacheWritebackAll
");
    end
end

if (!nids["sceGeEdramGetSize"]) 
    hooks.push(
"// Define if your exploit does not have access to  sceGeEdramGetSize
// You will see a linker message in the form:
//  undefined reference to `sceGeEdramGetSize'
#define FORCE_HARDCODED_VRAM_SIZE
")
end

if (!nids["sceUtilityCheckNetParam"]) 
    hooks.push(
"// Failing calls to sceUtilityCheckNetParam will probably deactivate net access
#define HOOK_ERROR_sceUtilityCheckNetParam
");
end

if (!nids["sceAudioGetChannelRestLen"] && nids["sceAudioGetChannelRestLength"]) 
    hooks.push("#define HOOK_sceAudioGetChannelRestLen_WITH_sceAudioGetChannelRestLength\n");
end

if (!nids["sceAudioOutput"] && nids["sceAudioOutputBlocking"]) 
    hooks.push("#define HOOK_sceAudioOutput_WITH_sceAudioOutputBlocking\n");
end

if (!nids["sceKernelReleaseSubIntrHandler"]) 
    hooks.push(
"// sceKernelReleaseSubIntrHandler is not imported by the game, so we undef the cleanup function. This might reduce HBL compatibility
#undef SUB_INTR_HANDLER_CLEANUP\n");
end



out = File.new( "exploit_config.h", "w")

out.puts %Q{// This is a pregenerated file made by gen_exploit_config.rb. Some sections are labelled as "TODO", you need to enter your values here

#ifndef EXPLOIT_CONFIG
#define EXPLOIT_CONFIG

//Where to load hbl.bin in Ram
// Has to be a place not occupied by the game
// a correct address can be found in an exploit with a call to sce_alloc
// For example:
// u32 uid = sceKernelAllocPartitionMemory(2, "test", PSP_SMEM_Low, 200 * 1024, NULL);
// u32 addr = sceKernelGetBlockHeadAddr(uid); 
// (the value you want is addr, try PSP_SMEM_High instead of Low to get a different address if needed
// Ideally, it should be either smaller than 0x08900000 or higher then 0x09000000.
// If you don't have any address in these areas, you can use GAME_PRELOAD_FREEMEM, which can free some memory *before* you load HBL, and maybe free some useful ranges
#define HBL_LOAD_ADDRESS TODO

// To get the correct values for TH_ADDR_LIST, EV_ADDR_LIST, SEMA_ADDR_LIST, GAME_FREEMEM_ADDR,
// the best is to use freemem.rb in the tools folder.
// otherwise you can gather these values with psplink

// Addresses where the threads to delete are defined
// can be found with psplink (thlist)
}
out.puts("#define TH_ADDR_LIST { " + addressOutput["TH_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
//Addresses where the event flags to delete can be found
//psplink evlist
}
out.puts("#define EV_ADDR_LIST { " + addressOutput["EV_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
//Addresses where the semaphores to delete can be found
//psplink smlist
}
out.puts("#define SEMA_ADDR_LIST { " + addressOutput["SEMA_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
// Define to Free the game module (e.g. minna no golf)
// Not all games need that
}
if (addressOutput["GAME_FREEMEM_ADDR"].size() == 0)
    out << "//"
end
out.puts("#define GAME_FREEMEM_ADDR { " + addressOutput["GAME_FREEMEM_ADDR"].join(", ")  + " }");

out.puts %Q{
// this needs to be defined before loading the common onfig below
#undef HBL_ROOT
#define HBL_ROOT "ms0:/PSP/SAVEDATA/TODO/"

// Define to free additional modules (net modules, etc...) (e.g. patapon2 demo)
// Not all games need that
#define UNLOAD_ADDITIONAL_MODULES


// Hooks (function overrides/replacements)
}

out.puts(hooks.join("\n"));


out.puts %Q{
// define DISABLE_P5_STUBS if P5 stubs cause a crash at startup
//#define DISABLE_P5_STUBS

//Vita: all files of HBL in one single folder, no subfolders
#define FLAT_FOLDER
#undef EBOOT_PATH
#define EBOOT_PATH HBL_ROOT"GAME/EBOOT.PBP"
#undef ELF_PATH
#define ELF_PATH HBL_ROOT"GAME/eboot.elf"
#undef HBL_PATH
#define HBL_PATH HBL_ROOT HBL_BIN
#undef LIB_PATH
#define LIB_PATH HBL_ROOT
#undef IMPORTS_PATH
# define IMPORTS_PATH HBL_ROOT"imports.config"


// if sceIoCHDIR crashes, don't call it, at all
// #define CHDIR_CRASH


// Perfect syscall code: not available anymore in 6.60, so everything here is empty

// For which firmware versions is perfect syscall estimation available?
#define SYSCALLS_KNOWN_FOR_FIRMWARES {  }
#define SYSCALLS_KNOWN_FOR_GO_FIRMWARES { }

// Reference library for syscall estimation, all syscalls for this library must be known
#define SYSCALL_REFERENCE_LIBRARY "sceOpenPSID"

// Syscall offsets, must be defined for all firmwares in SYSCALLS_KNOWN_FOR_FIRMWARES
#define SYSCALL_OFFSETS_500     {  }
#define SYSCALL_OFFSETS_500_CFW {  }

#define SYSCALL_OFFSETS_550     {  }
#define SYSCALL_OFFSETS_550_CFW {  }

#define SYSCALL_OFFSETS_570    {  }
#define SYSCALL_OFFSETS_570_GO {  }

#define SYSCALL_OFFSETS_600    {  }
#define SYSCALL_OFFSETS_600_GO {  }


// Kernel memory dump offsets for the PSP GO
#define SYSCALL_KERNEL_OFFSETS_620 {  }
#define SYSCALL_KERNEL_OFFSETS_630 { } // Not available
#define SYSCALL_KERNEL_OFFSETS_635 { } // Not available

#endif

}