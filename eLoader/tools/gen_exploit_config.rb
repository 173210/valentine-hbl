#!/usr/bin/ruby
# Generates a template for exploit_config.h
# This script is heaviliy adapted for VHBL: it assumes that perfect syscalls are not available, and that hbl needs to be run in a "flat" folder
#
# Required input files are:
#
# 1) "memdump.bin", a user memory dump from PSPLink with 
# "savemem 0x08800000 0x01800000 memdump.bin"
#
# 2) from the same game session as the memdump: "uidlist.txt", which is the the output of the "uidlist"
# command in PSPLink
#
# 3) "sdk.S", from your exploit
#
# 4) "lwmtxlist.txt", which is the output of the "lwmtxlist" command in PSPLink Mod by 173210
# You don't need it if the game doesn't have lwmutex.
#
# Initial code by JJS & wololo

max_nids = 64
call_address = 0x10000

# Copied from eLoaderconf.rb/stubs.rb/freemem.rb

class String
# Thanks to mon_Ouie for ruby 1.9 compatibility
	def to_a
		[self]
	end

	def hex_to_bin
		return gsub(/\s/,'').to_a.pack("H*")
	end
end

class Integer
	def mips(bytes)
		return to_s(16).rjust(bytes * 2, "0").hex_to_bin.reverse
	end

	def to_hex
		return to_s(16).rjust(2, "0").upcase
	end
end

def help()
puts %Q{
There are 2 modes to this tool:
* mode1 is used the first time you port HBL to a given exploit.
  you need to provide 3 files: memdump.bin, uidlist.txt, and sdk.S
  - memdump.bin: a user memory dump from PSPLink
       ("savemem 0x08800000 0x01800000 memdump.bin")
  - from the same game session as the memdump: "uidlist.txt",
       which is the the output of the "uidlist" command in PSPLink
  - sdk.S: the sdk from your exploit
  - "lwmtxlist.txt",
       which is the output of the "lwmtxlist" command in PSPLink Mod by 173210.
       You don't need it if the game doesn't have lwmutex.

* mode2 is used later on, when you don't have the memory dump available,
     but already have an existing port of the game
  mode 2 still requires sdk.S, the sdk from the exploit.
  mode2 takes a parameter: the codename of the game (e.g. lifejp)
  mode2's output is incomplete, so you need to manually
  grab the results and merge it with the existing exploit!!!
}
end

$gameName = nil;

if (ARGV.length > 0) then
	if (ARGV[0] == "-h") then
		help();
		die();
	end
	$gameName = ARGV[0];
end

# .lib.stub addresses
exploit_stubs_map = {
=begin
	# Project Life - KR Version (wololo, exploit by Teck4)
	"lifekr" =>
		[
			0x08A5A0DC, #game main module
			0x08ACCC30, #sceLibrary
			0x088009A0, #sceLibrary
			0x08AD3950, #sceLibrary
			0x08ADCA30, #sceLibrary
			0x08AE3A30, #sceLibrary
 		],

	# Project Life - US Version (wololo, exploit by Teck4)
	"lifeus" => 
		[
			0x08A5B328, #game main module
			0x08ACDC30, #sceLibrary
			0x088009A0, #sceLibrary
			0x08AD4950, #sceLibrary
			0x08ADDA30, #sceLibrary
			0x08AE4A30, #sceLibrary
 		],
	# Project Life - EU Version (wololo)
	"lifeeu" => 
		[
			0x08A5B940, #game main module
			0x08ACDC30, #sceLibrary
			0x088009A0, #sceLibrary
			0x08AD4950, #sceLibrary
			0x08ADDA30, #sceLibrary
			0x08AE4A30, #sceLibrary
		],

	# Project Life - JP Version (wololo)
	"lifejp" => 
		[
			0x08A5A280, #game main module
			0x08ACCC30, #sceLibrary
			0x088009A0, #sceLibrary
			0x08AD3950, #sceLibrary
			0x08ADCA30, #scelibrary
			0x08AE3A30, #scelibrary				
		],

	# Everybody's Tennis - EU Version (yosh)
	"tenniseu" =>
		[
			0x088009A0, #sceKernelLibrary
			0x08ABBF5C, #main
			0x09E94C30, #sceATRAC3plus_Library
			0x09EA08F0, #sceFont_Library
			0x09ED54A0, #scePsmfP_library
			0x09ED8770, #scePsmf_library
		],

	"tennisus" => 
		[
			0x088009A0, #sceKernelLibrary
			0x08ABBF1C, #main
			0x09E94C30, #sceATRAC3plus_Library
			0x09EA08F0, #sceFont_Library
			0x09ED54A0, #scePsmfP_library
			0x09ED8770, #scePsmf_library
		],
	"tennisjp" =>
		[
			0x088009A0, #sceKernelLibrary
			0x08AA8878, #main
			0x09E8FC30, #sceATRAC3plus_Library
			0x09E9B8F0, #sceFont_Library
			0x09ED0490, #scePsmfP_library
			0x09ED3720, #scePsmf_library
		],
	"tennishk" => 
		[
			0x088009A0, #sceKernelLibrary
			0x08ABC27C, #main
			0x09EA1C30, #sceATRAC3plus_Library
			0x09EAD8F0, #sceFont_Library
			0x09EE24A0, #scePsmfP_library
			0x09EE5770, #scePsmf_library
			0x09EED430, #sceMpeg_library
		],
=end
}


stubLibraries = [];
stubLibrariesNames = [];

addressOutput = {
    "TH_ADDR_LIST"=>[], 
    "ALARM_ADDR_LIST"=>[],
    "LWMUTEX_ADDR_LIST"=>[],
    "EV_ADDR_LIST"=>[], 
    "SEMA_ADDR_LIST"=>[],
    "VPL_ADDR_LIST"=>[],
    "FPL_ADDR_LIST"=>[],    
    "GAME_FREEMEM_ADDR"=>[],    
}

# If a $gameName is not provided, we assume we need to do the work from
# scratch. This means we need to provide a memory dump and uidlist
if ($gameName) then
  puts("Game name is provided, output will be partial");
  stubLibraries = exploit_stubs_map[$gameName];
  if (!stubLibraries) then
      puts("game code invalid");
      help();
      die();
  end
    addressOutput = {
        "TH_ADDR_LIST"=>["COPY VALUES FROM THE EXISTING exploit_config.h"], 
        "ALARM_ADDR_LIST"=>["COPY VALUES FROM THE EXISTING exploit_config.h"],
        "LWMUTEX_ADDR_LIST"=>["COPY VALUES FROM THE EXISTING exploit_config.h"],
        "EV_ADDR_LIST"=>["COPY VALUES FROM THE EXISTING exploit_config.h"], 
        "SEMA_ADDR_LIST"=>["COPY VALUES FROM THE EXISTING exploit_config.h"],
        "VPL_ADDR_LIST"=>[],
        "FPL_ADDR_LIST"=>[],        
        "GAME_FREEMEM_ADDR"=>["COPY VALUES FROM THE EXISTING exploit_config.h"],    
    }   
else
    fileEntry = Struct.new(:type, :uid, :name)
    addresses = Array.new
    currentHeader = nil
    baseAddress = 0x08800000

    if (!File.exists?("uidlist.txt") || !File.exists?("memdump.bin")) then
        help();
        die();
    end
    uidlist = File.new("uidlist.txt", "r")
    memdumpfile = File.new("memdump.bin", "r")
    memdumpfile.binmode
    memdump = memdumpfile.read


    #
    # Find Semaphore / Thread / evlist / game addresses
    # 

    #[Fpl]    UID 0x00288E0D (attr 0x0 entry 0x88014470)
    regexpHeader = /^\[(.+)\]    UID (0x.+) \(attr (0x.+) entry (0x.+)\)$/

    #(UID): 0x048E3761, (entry): 0x882471b8, (size): 48, (attr): 0xFF, (Name): sgx-ao-evf
    regexpEntry = /^\(UID\): (0x.+), \(entry\): (0x.+), \(size\): (.+), \(attr\): (0x.+), \(Name\): (.+)$/

    while (line = uidlist.gets)
        line.chomp!
        if (line.match(regexpHeader)) 
            line.scan(regexpHeader) { |name, uid, attr, entry|
                currentHeader = name
            }
        end
        
        if (line.match(regexpEntry)) 
            line.scan(regexpEntry) { |uid, entry, size, attr, name|
                if attr == "0xFF"
                    # skip thread stacks and the "main" thread which is unloaded with the module
                    if (name.index("stack:") == nil) and not ((currentHeader == "Thread") and (name == "main"))
                        addresses.push(fileEntry.new(currentHeader, uid, name))
                    end
                end
            }
        end
    end

    currentHeader = nil
    lwmtx = false

    addresses.each { |addressEntry|
        if addressEntry.type == "Thread"
            # the thread uid is right next to the thread stack
            index = memdump.index(addressEntry.uid.to_i(16).mips(4) + "FF".to_i(16).mips(1))
        else
            index = memdump.index(addressEntry.uid.to_i(16).mips(4))
        end
        
        if (index != nil)
            value = "0x0#{(index + baseAddress).to_s(16).upcase}"
                
            if addressEntry.type == "Thread"
                addressOutput["TH_ADDR_LIST"].push(value)
            elsif addressEntry.type == "Alarm"
                addressOutput["ALARM_ADDR_LIST"].push(value)
            elsif addressEntry.type == "LwMutex"
		lwmtx = 1
            elsif addressEntry.type == "EventFlag"
                addressOutput["EV_ADDR_LIST"].push(value)
            elsif addressEntry.type == "Semaphore"
                addressOutput["SEMA_ADDR_LIST"].push(value)
            elsif addressEntry.type == "SceSysMemMemoryBlock"
                addressOutput["GAME_FREEMEM_ADDR"].push(value)
            elsif addressEntry.type == "Vpl"
                addressOutput["VPL_ADDR_LIST"].push(value)  
            elsif addressEntry.type == "Fpl"
                addressOutput["FPL_ADDR_LIST"].push(value)                   
            end
        else
            puts "can't find address for UID " + addressEntry.uid;
        end
    }

    if (addressOutput["TH_ADDR_LIST"].empty? && addressOutput["ALARM_ADDR_LIST"].empty? && addressOutput["LWMUTEX_ADDR_LIST"].empty? && addressOutput["EV_ADDR_LIST"].empty? && addressOutput["SEMA_ADDR_LIST"].empty? && addressOutput["GAME_FREEMEM_ADDR"].empty?) then
	    puts "!!!! WARNING, NO DATA FOUND FOR THREADS, ALARM, LWMUTEX, EVENTS, SEMA, AND GAME ADDRESS. MAKE SURE THAT uidlist.txt IS IN UNIX FORMAT!!!"
    end

    if (lwmtx)
            lwmtxlist = File.new("lwmtxlist.txt", "r")

            #UID: 0xXXXXXXXX - Workarea: 0xYYYYYYYY - Name: ZZZZZZZZ
            regexpEntry = /^UID: .+ - Workarea: (0x.+) - Name: .+$/

            while (line = lwmtxlist.gets)
                line.chomp!
                if (line.match(regexpEntry)) 
                    line.scan(regexpEntry) { |addr|
                         addressOutput["LWMUTEX_ADDR_LIST"].push(addr)
                    }
                end
            end
    end
	
	

    #
    # Look for libraries loaded by the game, for stubs
    #

    uidlist = File.new("uidlist.txt", "r")
    libraryNames = [];

    # [SceModule] 
    # (UID): 0x03E85D71, (entry): 0x881f42e8, (size): 28, (attr): 0x0, (Name): sceATRAC3plus_Library
    # [SceSysMemMemoryBlock]    UID 0x002C9817 (attr 0x0 entry 0x880164c0)

    sceModuleRgx = /\[SceModule\]/
    sceSysMemRgx = /\[SceSysMemMemoryBlock\]/
    regexpLibname = /^\s*(.+)\(Name\): (.+)$/
    scemoduleFound = false;
    while (line = uidlist.gets)
        line.chomp!
        if (line.match(sceModuleRgx)) 
            scemoduleFound = true;
        end
        
        if (line.match(sceSysMemRgx)) 
            scemoduleFound = false;
        end    
        
        if (scemoduleFound && line.match(regexpLibname)) 
            line.scan(regexpLibname) { |stuff, name|
                libraryNames << name;
            }
        end
    end


    libraryNames.each { |library|
        pos = memdump.index(library);
        if pos then
            pos = pos + 40; 
            stubLibraries << memdump[pos, 4].unpack("V")[0]
            stubLibrariesNames << library
        else
            #puts library + " not found"
        end

    }    
end








puts "stubs found:"
stubLibraries.each { |x|
	puts x.to_hex
}
puts stubLibrariesNames;
puts "***"

# HBL stubs
Config = [
	{
		:lib => "InterruptManager",
		:functions => [
			[0xD61E6961, "sceKernelReleaseSubIntrHandler"],
		],
	},
	{
		:lib => "IoFileMgrForUser",
		:functions => [
			[0x55F4717D, "sceIoChdir"],
			[0x810c4bc3, "sceIoClose"],
			[0xEB092469, "sceIoDclose"],
			[0xB29DDF9C, "sceIoDopen"],
			[0xE3EB004C, "sceIoDread"],
			[0x27EB27B8, "sceIoLseek"],
			[0x109f50bc, "sceIoOpen"],
			[0x6A638D83, "sceIoRead"],
			[0x42ec03ac, "sceIoWrite"],
		],
	},
	{
		:lib => "ModuleMgrForUser",
		:functions => [
			[0x8F2DF740, "ModuleMgrForUser_8F2DF740"], #sceKernelSelfStopUnloadModuleWithStatus, see hook.c
			[0xD8B73127, "sceKernelGetModuleIdByAddress"],
			[0x644395E2, "sceKernelGetModuleIdList"],
			[0x977DE386, "sceKernelLoadModule"],
			[0xD1FF982A, "sceKernelStopModule"],
			[0x2E0911AA, "sceKernelUnloadModule"],
		],
	},
	{
		:lib => "UtilsForUser",
		:functions => [
			# only one of sceKernelDcacheWritebackInvalidateAll and sceKernelDcacheWritebackAll is used, it depends on the exploit,
            [0xB435DEC5, "sceKernelDcacheWritebackInvalidateAll"],
			[0x79D1C3FA, "sceKernelDcacheWritebackAll"],
            [0x3EE30821, "sceKernelDcacheWritebackRange"],
            [0x34B9FA9E, "sceKernelDcacheWritebackInvalidateRange"],
			[0x920F104A, "sceKernelIcacheInvalidateAll"],
			[0xC2DF770E, "sceKernelIcacheInvalidateRange"],
        ],
    }  ,  
    { 
        :lib => "ThreadManForUser",
        :functions => [ 
            [0xCEADEB47, "sceKernelDelayThread"],
            [0xF475845D, "sceKernelStartThread"],
            [0x446D8DE6, "sceKernelCreateThread"], 
            [0x616403BA, "sceKernelTerminateThread"], 
            [0x383F7BCC, "sceKernelTerminateDeleteThread"], 
            [0x809CE29B, "sceKernelExitDeleteThread"],
            [0x9FA03CD3, "sceKernelDeleteThread"], 
            [0x28B6489C, "sceKernelDeleteSema"],
            [0x60107536, "sceKernelDeleteLwMutex"],
            [0xED1410E0, "sceKernelDeleteFpl"],
            [0x89B3D48C, "sceKernelDeleteVpl"],
            [0xef9e4c70, "sceKernelDeleteEventFlag"], 
            [0x7E65B999, "sceKernelCancelAlarm"],
            [0xAA73C935, "sceKernelExitThread"],
            [0x68DA9E36, "sceKernelDelayThreadCB"],
            [0x82826F70, "sceKernelSleepThreadCB"],            
            [0x876DBFAD, "sceKernelSendMsgPipe"],
            [0x74829B76, "sceKernelReceiveMsgPipe"],
            [0x884C9F90, "sceKernelTrySendMsgPipe"],
            [0xDF52098F, "sceKernelTryReceiveMsgPipe"],
            [0x293B45B8, "sceKernelGetThreadId"],
            [0xE81CAF8F, "sceKernelCreateCallback"],
            [0x3F53E640, "sceKernelSignalSema"],
            [0x4E3A1105, "sceKernelWaitSema"],
            [0xD6DA4BA1, "sceKernelCreateSema"],
            [0x977DE386, "sceKernelLoadModule"],  
            [0x9944F31F, "sceKernelSuspendThread"],
            [0x75156E8F, "sceKernelResumeThread"],
            [0x6D212BAC, "sceKernelWaitSemaCB"],            
        ],
    }   , 
    { 
        :lib => "LoadExecForUser",
        :functions => [
            [0x05572A5F, "sceKernelExitGame"],   
            [0x4AC57943, "sceKernelRegisterExitCallback"],            
        ],
    },    
    { 
        :lib => "SysMemUserForUser",
        :functions => [
            [0x237DBD4F, "sceKernelAllocPartitionMemory"],
            [0x9D9A5BA1, "sceKernelGetBlockHeadAddr"],
            [0xB6D61D02, "sceKernelFreePartitionMemory"],
# The two following can be overriden by some of our code, which will not fail
# Our code is slow though, so if syscalls can be done 100% perfect at some point let's put those back
#            [0xF919F628, "sceKernelTotalFreeMemSize"],
#            [0xA291F107, "sceKernelMaxFreeMemSize"],
        ],
    },   
    { 
        :lib => "sceDisplay",
        :functions => [
            [0x289D82FE, "sceDisplaySetFrameBuf"],
            [0x984C27E7, "sceDisplayWaitVblankStart"],
            [0x46F186C3, "sceDisplayWaitVblankStartCB"],
        ],
    },  
    { 
        :lib => "sceCtrl",
        :functions => [
            [0x1F803938, "sceCtrlReadBufferPositive"],
            [0x3A622550, "sceCtrlPeekBufferPositive"],
        ],
    },
    {
    	:lib => "sceAudio",
    	:functions => [
    		[0x6FC46853, "sceAudioChRelease"],
            [0xB011922F, "sceAudioGetChannelRestLength"],
            [0x136CAF51, "sceAudioOutputBlocking"],
            [0x13F592BC, "sceAudioOutputPannedBlocking"],
            [0x5EC81C55, "sceAudioChReserve"],
            [0x5C37C0AE, "sceAudioSRCChRelease"],
    	],
    },  
    {
    	:lib => "sceRtc",
    	:functions => [
    		[0xE7C27D1B, "sceRtcGetCurrentClockLocalTime"],
    	],
    }, 
    {
    	:lib => "scePower",
    	:functions => [
			[0x469989AD, "scePower_469989AD"], # == scePowerSetClockFrequency see hook.c
    		[0xEBD177D6, "scePower_EBD177D6"], # == scePowerSetClockFrequency see hook.c
    	],
    },     
   	{
    	:lib => "sceUtility",
    	:functions => [
            [0x2A2B3DE0, "sceUtilityLoadModule"],
            [0x1579A159, "sceUtilityLoadNetModule"],
            [0x0D5BC6D2, "sceUtilityLoadUsbModule"],
            [0xC629AF26, "sceUtilityLoadAvModule"],
            [0xE49BFE92, "sceUtilityUnloadModule"],
            [0x64D50C56, "sceUtilityUnloadNetModule"],
            [0xF64910F0, "sceUtilityUnloadUsbModule"],
            [0xF7D8D092, "sceUtilityUnloadAvModule"],
    	],
    },  
   	{
    	:lib => "sceGe_user",
    	:functions => [
    		[0x1F6752AD, "sceGeEdramGetSize"],
    		[0xE47E40E4, "sceGeEdramGetAddr"],
    	],
    }
]


hooks = Array.new;
nids = Hash.new;
sdk = File.new("sdk.S", "r")

# Matches the following regexp
#	AddNID sceIoLseek, 0x08A885D0
regexpNID = /^\sAddNID (.+), (.+)$/
while (line = sdk.gets)
	line.chomp!
	if (line.match(regexpNID)) 
		line.scan(regexpNID) { |name, addr|
			nids[name] = addr;
		}
	end
end

CantDelete = {
    "sceIoDread" => 1,
    "sceIoDopen" => 1,
    "sceIoDclose" => 1,
    "scePower_EBD177D6" => !nids["scePower_469989AD"], # TODO handle power functions properly
    "sceKernelGetModuleIdByAddress" => 1, 
    "sceKernelCancelAlarm" => !(addressOutput["ALARM_ADDR_LIST"].empty?), 
    "sceKernelDcacheWritebackAll" => !nids["sceKernelDcacheWritebackRange"],
    "sceKernelDeleteLwMutex" => !(addressOutput["LWMUTEX_ADDR_LIST"].empty?),
    "sceKernelDeleteEventFlag" => !(addressOutput["EV_ADDR_LIST"].empty?),
    "sceKernelFreePartitionMemory" => 1,
    "sceKernelDeleteVpl" =>  !(addressOutput["VPL_ADDR_LIST"].empty?), 
    "sceKernelDeleteFpl" =>  !(addressOutput["FPL_ADDR_LIST"].empty?),
    "sceKernelDelayThread" => 1,
    "sceKernelDeleteThread" => 1,
    "sceKernelSleepThreadCB" => !nids["sceKernelDelayThreadCB"],
    "sceKernelTerminateThread" => !nids["sceKernelTerminateDeleteThread"],
	"sceKernelGetThreadId" => 1,
	"sceKernelCreateSema" => 1,
    "sceAudioSRCChRelease" => 1
}
#no Solution for those now :(


def deleteConfig(name)
    puts("Removing #{name}");
    if (CantDelete[name]) then
        puts("HBL needs #{name} so we're Keeping it, but it seems your game does not import it.");
        return false;
    else
        Config.each {|libinfo | 
            libinfo[:functions].delete_if {|x| x[1] == name }
        }
        Config.delete_if{ |x| x[:functions].size == 0 }
        return true;
    end
end

if (addressOutput["ALARM_ADDR_LIST"].empty?) then
    deleteConfig("sceKernelCancelAlarm")
end

if (addressOutput["LWMUTEX_ADDR_LIST"].empty?) then
    deleteConfig("sceKernelDeleteLwMutex")
end

if (addressOutput["EV_ADDR_LIST"].empty?) then
    deleteConfig("sceKernelDeleteEventFlag")
end

if (addressOutput["GAME_FREEMEM_ADDR"].empty?) then
    deleteConfig("sceKernelFreePartitionMemory")
end

if (addressOutput["VPL_ADDR_LIST"].empty?) then
	deleteConfig("sceKernelDeleteVpl")
end

if (addressOutput["FPL_ADDR_LIST"].empty?) then
	deleteConfig("sceKernelDeleteFpl")
end

if (!nids["sceKernelDeleteThread"] && nids["sceKernelTerminateDeleteThread"]) then
	deleteConfig("sceKernelTerminateThread")
end

#
# Defines a bunch of common hooks
# We also filter out the imports that are not needed. We need to end up with 64 or less of them
#
if (!nids["sceKernelWaitSema"] && nids["sceKernelWaitSemaCB"]) then
	hooks.push(
"// define if your exploit does not have access to sceKernelWaitSema
#undef WAIT_SEMA
#define WAIT_SEMA sceKernelWaitSemaCB
");
end

if (!nids["sceGeEdramGetSize"])
	hooks.push(
"// Define if your exploit does not have access to  sceGeEdramGetSize
// You will see a linker message in the form:
//  undefined reference to `sceGeEdramGetSize'
#define FORCE_HARDCODED_VRAM_SIZE
")
    deleteConfig("sceGeEdramGetSize")
end

if (!nids["sceUtilityLoadModule"] &&
    (nids["sceUtilityLoadNetModule"] ||
     nids["sceUtilityLoadUsbModule"] ||
     nids["sceUtilityLoadAvModule"]))
    hooks.push("#define USE_EACH_UTILITY_MODULE_LOAD_FUNCTION
")
    if (nids["sceUtilityLoadNetModule"])
        hooks.push("#define USE_NET_MODULE_LOAD_FUNCTION
")
    end
    if (nids["sceUtilityLoadUsbModule"])
        hooks.push("#define USE_USB_MODULE_LOAD_FUNCTION
")
    end
    if (nids["sceUtilityLoadAvModule"])
        hooks.push("#define USE_AV_MODULE_LOAD_FUNCTION
")
    end
else
    deleteConfig("sceUtilityLoadNetModule")
    deleteConfig("sceUtilityLoadUsbModule")
    deleteConfig("sceUtilityLoadAvModule")
end

if (!nids["sceUtilityUnloadModule"])
    if (nids["sceUtilityUnloadNetModule"] ||
        nids["sceUtilityUnloadUsbModule"] ||
        nids["sceUtilityUnloadAvModule"])
        hooks.push("#define USE_EACH_UTILITY_MODULE_UNLOAD_FUNCTION
")
        if (nids["sceUtilityUnloadNetModule"])
            hooks.push("#define USE_NET_MODULE_UNLOAD_FUNCTION
")
        end
        if (nids["sceUtilityUnloadUsbModule"])
            hooks.push("#define USE_USB_MODULE_UNLOAD_FUNCTION
")
        end
        if (nids["sceUtilityUnloadAvModule"])
            hooks.push("#define USE_AV_MODULE_UNLOAD_FUNCTION
")
        end
    else
        hooks.push("#define DISABLE_UNLOAD_UTILITY_MODULES
")
    end
else
    deleteConfig("sceUtilityUnloadNetModule")
    deleteConfig("sceUtilityUnloadUsbModule")
    deleteConfig("sceUtilityUnloadAvModule")
end

if (!nids["sceUtilityCheckNetParam"]) 
	hooks.push(
"// Failing calls to sceUtilityCheckNetParam will probably deactivate net access
#define HOOK_ERROR_sceUtilityCheckNetParam
");
end

if (!nids["sceRtcGetCurrentTick"] && nids["sceRtcGetCurrentClockLocalTime"]) then
	hooks.push(
"#define HOOK_sceRtcGetCurrentTick
"); 
end

hook_if_not_exist = [
	"sceKernelGetThreadId",
	"sceKernelTotalFreeMemSize",
	"sceKernelLoadModule",
];

hook_if_not_exist.each { |v| 
	if (!nids[v]) then
		hooks.push("#define HOOK_#{v}\n");
		deleteConfig(v);
	end
}


a_WITH_b_hooks ={
	"sceAudioGetChannelRestLen" => "sceAudioGetChannelRestLength",
	"sceAudioOutput" => "sceAudioOutputBlocking",
    "sceAudioOutput2GetRestSample" => "sceAudioGetChannelRestLength",
    "sceAudioOutputBlocking" => "sceAudioOutputPannedBlocking",
    "sceAudioOutputPanned" => "sceAudioOutputPannedBlocking",

    "sceCtrlPeekBufferPositive" => "sceCtrlReadBufferPositive",
    "sceCtrlReadBufferPositive" => "sceCtrlPeekBufferPositive",    

    "sceDisplayWaitVblankStart" => "sceDisplayWaitVblankStartCB",
    "sceDisplayWaitVblankStart" => "sceKernelDelayThread",
    "sceDisplayWaitVblankStartCB" => "sceDisplayWaitVblankStart" ,  
    
    "sceKernelDcacheWritebackInvalidateAll" => "sceKernelDcacheWritebackInvalidateRange",
    "sceKernelDcacheWritebackInvalidateAll" => "sceKernelDcacheWritebackAll",
    "sceKernelDcacheWritebackAll" => "sceKernelDcacheWritebackRange",     
    "sceKernelIcacheInvalidateAll" => "sceKernelIcacheInvalidateRange",
    "sceKernelReceiveMsgPipe" => "sceKernelTryReceiveMsgPipe",
    "sceKernelTryReceiveMsgPipe" => "sceKernelReceiveMsgPipe",
    "sceKernelSelfStopUnloadModule" => "ModuleMgrForUser_8F2DF740",
    "sceKernelSleepThreadCB" => "sceKernelDelayThreadCB",
    "sceKernelTerminateThread" => "sceKernelTerminateDeleteThread",
    "sceKernelWaitSema" =>  "sceKernelWaitSemaCB",

    "scePowerSetClockFrequency" => "scePower_EBD177D6",
    
    "sceRtcGetCurrentClock" => "sceRtcGetCurrentClockLocalTime",


    
    # Dummy: need real functions
    "sceKernelChangeCurrentThreadAttr" => "dummy",
    "sceCtrlSetIdleCancelThreshold"  => "dummy",
    "sceImposeSetHomePopup"   => "dummy",
    "sceKernelIcacheInvalidateAll" => "dummy",
    "sceKernelReferThreadStatus" => "dummy",
    "sceKernelWakeupThread" => "dummy",
    "sceDisplayGetVcount" => "dummy",
    "sceKernelDeleteSema" => "dummy",
    "sceKernelVolatileMemUnlock" => "dummy"
};

delete_b_if_a_exists ={
	"sceCtrlPeekBufferPositive" => "sceCtrlReadBufferPositive",

	"sceKernelDcacheWritebackInvalidateAll" => "sceKernelDcacheWritebackInvalidateRange",
	"sceKernelDcacheWritebackAll" => "sceKernelDcacheWritebackRange",
	"sceKernelIcacheInvalidateAll" => "sceKernelIcacheInvalidateRange",
	"sceKernelWaitSema" =>  "sceKernelWaitSemaCB",
};

a_WITH_b_hooks.each { |k, v| 
	if (!nids[k] && (nids[v] || v == "dummy")) then
		hooks.push("#define HOOK_#{k}_WITH_#{v}\n");
		#deleteConfig(k);
	end
}

delete_b_if_a_exists.each { |k, v| 
	if (nids[k]) then
		deleteConfig(v);
	end
}

if (!nids["sceIoChdir"])
	hooks.push(
"// if sceIoCHDIR crashes, don't call it, at all
#define CHDIR_CRASH
");
	deleteConfig("sceIoChdir")
end

if (!nids["sceKernelUtilsMt19937Init"] || !nids["sceKernelUtilsMt19937UInt"])
	hooks.push("
#define HOOK_mersenne_twister_rdm
");  
end

nb_nids = 0;
nids_offset = 0;
Config.each {|libinfo | 
	nb_nids = nb_nids + libinfo[:functions].size
	nids_offset = nids_offset + libinfo[:lib].size + 1 + 3 * 4
}

# Delete functions that are not defined. This will yield compilation error if needed,
# This is the best way to avoid runtime issues if syscall estimation is not working
Config.each {|libinfo |
	libinfo[:functions].each{|function|
		if (!nids[function[1]]) then
			if (deleteConfig(function[1])) then
				nb_nids -= 1;
			end
		end
	}
}



# Handle threads in a somewhat magical way
if ((!nids["sceKernelTerminateThread"] || !nids["sceKernelDeleteThread"]) && (!nids["sceKernelTerminateDeleteThread"])) then
	if (nids["sceKernelSuspendThread"] && nids ["sceKernelExitDeleteThread"] && nids["sceKernelResumeThread"])     then
		hooks.push(
"// Alternate solution to handle threads (experimental)
//#define SUSPEND_THEN_DELETE_THREADS
");
	else
		puts("ERROR, No thread handling function, most likely you won't be able to port HBL to this game")
	end
else
	deleteConfig("sceKernelSuspendThread")
	deleteConfig("sceKernelResumeThread")
end

net_util = false;
nids.each {|nidname |
	if (nidname[0].start_with?("sceNet")) then
		net_util = true;
		break;
	end
}

if (!net_util) then
	hooks.push(
"// Avoid loading NET, USB and NP utilities if the game doesn't import them (required since firmware 3.00)
#define HOOK_UTILITY
#define AVOID_NET_UTILITY
");
end

a_WITH_b_hooks.each { |k, v| 
	if (!nids[k] && (nids[v] || v == "dummy")) then
		if (deleteConfig(k)) then
			nb_nids -= 1;
		end
	end
}

nb_nids = 0;
nids_offset = 0;
Config.each {|libinfo |
	nb_nids = nb_nids + libinfo[:functions].size
	nids_offset = nids_offset + libinfo[:lib].size + 1 + 3 * 4
}

if (nb_nids > max_nids) then
	puts "TOO MANY NIDS";
	exit;
end

# Write new loader.h
curr_addr = call_address #0x10000; #0x0880FF00 # 0x00013F00
output_folder = "output"
Dir.mkdir(output_folder) unless File.directory?(output_folder);
out_loader_h = File.new( output_folder + "/loader.h", "w");
out_loader_h.binmode;
out_loader_h.puts %Q{/* This file was automatically generated by eLoaderconf.rb */
#ifndef ELOADER_LOADER
#define ELOADER_LOADER

// HBL stubs size
}

out_loader_h.puts "#define NUM_HBL_IMPORTS"  + " "  + nb_nids.to_s(10);
out_loader_h.puts "#define HBL_STUBS_START"  + " 0x"  +  curr_addr.to_s(16);
out_loader_h << "// #define HBL_FUNCTION_NIDS { "

Config.each {|libinfo |
	libinfo[:functions].each {|nidinfo |
		out_loader_h << "0x" + nidinfo[0].to_s(16) + ",";
	}
}

out_loader_h.puts " }"

out_loader_h.puts %Q{
#endif
}

out = File.new( output_folder + "/sdk_hbl.S", "w")
out.binmode();

cfg_folder = output_folder + "/config";
Dir.mkdir(cfg_folder) unless File.directory?(cfg_folder);

out_conf = File.new( cfg_folder + "/IMPORTS.DAT"  , "w");
puts cfg_folder + "/IMPORTS.DAT";
out_conf.binmode;
out_conf.write(stubLibraries.size.mips(4));
out_conf.write(Config.size.mips(4));
out_conf.write(nb_nids.mips(4));
stubLibraries.each{ |stub_addr|
	out_conf.write(stub_addr.mips(4));
}

out.puts %Q{# This file was automatically generated by eLoaderconf.rb
# If you want to edit this file, edit eLoaderconf.rb instead
.macro AddNID funcname, offset

	.globl	\\funcname
	.ent	\\funcname
	.type	\\funcname, @function
\\funcname = \\offset
#\\funcname:
#	lui $v0, 0x1		# Put 0x10000 in $v0, $v0 is return value so there's no need to back it up
#	lw $v0, 0x18 ($v0)	# Get HBL stubs address, see eloader.c or loader.c for more info
#	addi $v0, $v0, \\offset	# Add offset
#	jr $v0			# Jump to stub
#	nop			# Leave this delay slot empty!
	.end	\\funcname
	.size	\\funcname, 8

.endm

	.text
	.align	2

}


nids_offset_file = nids_offset + 12 + stubLibraries.size * 4;
Config.each {|libinfo |
	lib = libinfo[:lib];
	out_conf.write(lib);
	out_conf.write("\0");
	out_conf.write(libinfo[:functions].size.mips(4));
	out_conf.write(nids_offset_file.mips(8));
	nids_offset_file = nids_offset_file + libinfo[:functions].size * 4
}

Config.each {|libinfo | 
	out.puts;
	out.puts("# " + libinfo[:lib] + "(" + libinfo[:functions].size.to_s + ")");
	max = 0
	libinfo[:functions].each {|nidinfo | 
		if nidinfo[1].size > max then max = nidinfo[1].size end
	}
	libinfo[:functions].each {|nidinfo | 
		out.puts("\tAddNID #{nidinfo[1]}, 0x" +  curr_addr.to_s(16).rjust(4, "0") + " " * (max - nidinfo[1].size) + " # 0x" + nidinfo[0].to_s(16));
		out_conf.write(nidinfo[0].mips(4));
		curr_addr += 8;
	}
}

out.puts %Q{
	.ident "HBL-SDK"
}

out_conf.close
out.close


out = File.new( output_folder + "/exploit_config.h", "w")

out.puts %Q{// This is a pregenerated file made by gen_exploit_config.rb. Some sections are labelled as "TODO", you need to enter your values here

#ifndef EXPLOIT_CONFIG
#define EXPLOIT_CONFIG

//Where to load hbl.bin in Ram
// Has to be a place not occupied by the game
// a correct address can be found in psplink, by typing:
// malloc 2 test l 204800
// (the value you want is head address, try h instead of lto get a different address if needed
// Ideally, it should be either smaller than 0x08900000 or higher then 0x09000000.
// If you don't have any address in these areas, you can use GAME_PRELOAD_FREEMEM, which can free some memory *before* you load HBL, and maybe free some useful ranges
#define HBL_LOAD_ADDR TODO

// To get the correct values for TH_ADDR_LIST, ALARM_ADDR_LIST, LWMUTEX_ADDR_LIST, EV_ADDR_LIST, SEMA_ADDR_LIST, GAME_FREEMEM_ADDR,
// the best is to use freemem.rb in the tools folder.
// otherwise you can gather these values with psplink

// Addresses where the threads to delete are defined
// can be found with psplink (thlist)
}
out.puts("#define TH_ADDR_LIST { " + addressOutput["TH_ADDR_LIST"].join(", ")  + " }");

out.puts %Q[
//Addresses where the alarms to delete can be found
//psplink uidlist
]
if (addressOutput["ALARM_ADDR_LIST"].size() == 0)
    out << "//"
end
out.puts("#define ALARM_ADDR_LIST { " + addressOutput["ALARM_ADDR_LIST"].join(", ")  + " }");

out.puts %Q[
//Addresses where the workarea of the lwmutexes to delete can be found
//You need PSPLink Mod by 173210
//psplink lwmutexlist
]
if (addressOutput["LWMUTEX_ADDR_LIST"].size() == 0)
    out << "//"
end
out.puts("#define LWMUTEX_ADDR_LIST { " + addressOutput["LWMUTEX_ADDR_LIST"].join(", ")  + " }");

out.puts %Q[
//Addresses where the event flags to delete can be found
//psplink evlist
]
if (addressOutput["EV_ADDR_LIST"].size() == 0)
	out << "//"
end
out.puts("#define EV_ADDR_LIST { " + addressOutput["EV_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
//Addresses where the semaphores to delete can be found
//psplink smlist
}
if (addressOutput["SEMA_ADDR_LIST"].size() == 0)
	out << "//"
end
out.puts("#define SEMA_ADDR_LIST { " + addressOutput["SEMA_ADDR_LIST"].join(", ")  + " }");

if (addressOutput["VPL_ADDR_LIST"].size() == 0)
	out << "//"
end
out.puts("#define VPL_ADDR_LIST { " + addressOutput["VPL_ADDR_LIST"].join(", ")  + " }");

if (addressOutput["FPL_ADDR_LIST"].size() == 0)
	out << "//"
end

out.puts("#define FPL_ADDR_LIST { " + addressOutput["FPL_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
// Define to Free the game module (e.g. minna no golf)
// Not all games need that
}
if (addressOutput["GAME_FREEMEM_ADDR"].size() == 0)
	out << "//"
end
out.puts("#define GAME_FREEMEM_ADDR { " + addressOutput["GAME_FREEMEM_ADDR"].join(", ")  + " }");

out.puts %Q{
// Replace the "TODO" below with the code of your game (e.g UCUS12345)
#define HBL_ROOT "ms0:/PSP/SAVEDATA/TODO/"

// Some hooks are not really wise if the game already imports them. Files generated by gen_cfg_exploit try to define hooks
//cleverly based on the game imports, but at runtime additional stubs might be found that make these hooks obsolete.
// This define will prevent some of your hooks from being active, because HBL will decide at runtime that it is not a good idea to do the override
#define DONT_HOOK_IF_FUNCTION_IS_IMPORTED

// Define to free additional modules (net modules, etc...) (e.g. patapon2 demo)
// Not all games need that
#define UNLOAD_ADDITIONAL_MODULES

//There is in general no good reason to comment that one
//It searches for additional syscalls.
#define LOAD_MODULES_FOR_SYSCALLS
}

if (nids["sceKernelReleaseSubIntrHandler"]) 
	out.puts %Q{
#define SUB_INTR_HANDLER_CLEANUP
}
end

out.puts %Q{
// Hooks (function overrides/replacements)
}

out.puts(hooks.join("\n"));

out.puts %Q{
// Perfect syscall code: not available anymore in 6.60, so everything here is empty

// For which firmware versions is perfect syscall estimation available?
#define SYSCALLS_KNOWN_FW {  }
#define SYSCALLS_KNOWN_GO_FW { }

// Reference library for syscall estimation, all syscalls for this library must be known
#define SYSCALL_REF_LIB "sceOpenPSID"

// Syscall offsets, must be defined for all firmwares in SYSCALLS_KNOWN_FW
//#define SYSCALL_OFFSETS_500     {  }
//#define SYSCALL_OFFSETS_500_CFW {  }

//#define SYSCALL_OFFSETS_550     {  }
//#define SYSCALL_OFFSETS_550_CFW {  }

//#define SYSCALL_OFFSETS_570    {  }
//#define SYSCALL_OFFSETS_570_GO {  }

//#define SYSCALL_OFFSETS_600    {  }
//#define SYSCALL_OFFSETS_600_GO {  }


// Kernel memory dump offsets for the PSP GO
//#define SYSCALL_KERNEL_OFFSETS_620 {  }
//#define SYSCALL_KERNEL_OFFSETS_630 { } // Not available
//#define SYSCALL_KERNEL_OFFSETS_635 { } // Not available

#endif

}
