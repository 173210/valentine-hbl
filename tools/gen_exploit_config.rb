#!/usr/bin/ruby
# Generates a template for exploit_config.h
# This script is heaviliy adapted for VHBL: it assumes that perfect syscalls are not available, and that hbl needs to be run in a "flat" folder
#
# Required input files are:
#
# 1) "memdump.bin", a user memory dump from PSPLink with 
# "savemem 0x08800000 0x01800000 memdump.bin"
#
# 2) from the same game session as the memdump: "uidlist.txt", which is the the output of the "uidlist"
# command in PSPLink
#
# 3) "lwmtxlist.txt", which is the output of the "lwmtxlist" command in PSPLink Mod by 173210
# You don't need it if the game doesn't have lwmutex.
#
# Initial code by JJS & wololo

require 'digest/sha1'

max_nids = 64
call_address = 0x10000

# Copied from eLoaderconf.rb/stubs.rb/freemem.rb

class String
	def to_nid
		return self[-9] == "_" ? self[-8..-1].hex : Digest::SHA1.digest(self).unpack("V")[0]
	end
end

class Integer
# Thanks to mon_Ouie for ruby 1.9 compatibility
	def to_a
		[self]
	end

	def to_hex
		return to_s(16).rjust(2, "0").upcase
	end
end

def help
    puts %Q{
There are 2 modes to this tool:
*  mode1 is used the first time you port HBL to a given exploit.
   you need to provide 3 files: memdump.bin, uidlist.txt, and lwmtxlist.txt
  - memdump.bin: a user memory dump from PSPLink
       ("savemem 0x08800000 0x01800000 memdump.bin")
  - from the same game session as the memdump: "uidlist.txt",
       which is the the output of the "uidlist" command in PSPLink
  - "lwmtxlist.txt":
       the output of the "lwmtxlist" command in PSPLink Mod by 173210.
       You don't need it if the game doesn't have lwmutex.

*  mode2 is used later on, when you don't have the memory dump available,
  but already have an existing port of the game.
   mode2's output is incomplete, so you need to manually
  grab the results and merge it with the existing exploit!!!
   you need to provide 2 files: sdk.S and exploit_config.h
  - sdk.S:
      the sdk from your exploit
  - exploit_config.h:
      your current configuration file
}
end

config_values = {
	"TH_ADDR_LIST" => [], 
	"ALARM_ADDR_LIST" => [],
	"LWMUTEX_ADDR_LIST" => [],
	"EV_ADDR_LIST" => [], 
	"SEMA_ADDR_LIST" => [],
	"VPL_ADDR_LIST" => [],
	"FPL_ADDR_LIST" => [],
	"GAME_FREEMEM_ADDR" => [],
}

net_util = false
nids = []

if (File.exists?('memdump.bin') && File.exists?('uidlist.txt'))
	#
	# Find Semaphore / Thread / evlist / game addresses
	#
	base = 0x08800000
	ent_type = nil
	lwmtx = false

	memdump = IO.binread('memdump.bin')
	IO.foreach('uidlist.txt') { |line|
		#[Fpl]    UID 0x00288E0D (attr 0x0 entry 0x88014470)
		if line =~ /^\[(.+)\].+$/
			ent_type = $1
			next
		end

		#(UID): 0x048E3761, (entry): 0x882471b8, (size): 48, (attr): 0xFF, (Name): sgx-ao-evf
		line.scan(/\(UID\): (0x.+?),.*\(attr\): (0x.+?),.*\(Name\): (.+)$/) {
			|ent_uid, ent_attr, ent_name|

			if ent_type == 'SceModule'
				if !nids.empty?
					break
				end

				pos = memdump.index(ent_name)
				if !pos
					break
				end

				stub_top = memdump[pos + 40, 4].unpack('V')[0]
				stub_end = memdump[pos + 44, 4].unpack('V')[0]
				entry_addr = memdump[pos + 72, 4].unpack('V')[0]

				if entry_addr != 0x08804000
					break
				end

				pos = stub_top - base
				stub_end -= base
				while pos < stub_end
					lib_name = memdump[pos, 4].unpack('V')[0]
					stub_size = memdump[pos + 10, 2].unpack('v')[0]
					nid_p = memdump[pos + 12, 4].unpack('V')[0]
					jump_p = memdump[pos + 16, 4].unpack('V')[0]

					if memdump[lib_name - base..-1].start_with?('sceNet')
						net_util = true
					end

					memdump[nid_p - base, stub_size * 4].unpack('V*') {
						|nid|

						nids << [nid, jump_p]
						jump_p += 8
					}

					pos += 20
				end

				break
			end

			# skip kernel objects
			if ent_attr != '0xFF'
				break
			end

			index = memdump.index(ent_uid.hex.to_a.pack("V"))
			if !index
				puts "can't find address for UID " + ent_uid;
				break
			end

			value = "0x0#{(index + base).to_s(16).upcase}"
                
			if ent_type == 'Thread'
				# skip main thread
				if !ent_name.include?('main')
					config_values['TH_ADDR_LIST'] << value
				end
			elsif ent_type == 'Alarm'
				config_values['ALARM_ADDR_LIST'] << value
			elsif ent_type == 'LwMutex'
				lwmtx = true
			elsif ent_type == 'EventFlag'
				config_values['EV_ADDR_LIST'] << value
			elsif ent_type == 'Semaphore'
				config_values['SEMA_ADDR_LIST'] << value  
			elsif ent_type == 'SceSysMemMemoryBlock'
				# skip thread stacks
				if !ent_name.include?('stack:')
					config_values['GAME_FREEMEM_ADDR'] << value
				end
			elsif ent_type == 'Vpl'
				config_values['VPL_ADDR_LIST'] << value  
			elsif ent_type == 'Fpl'
				config_values['FPL_ADDR_LIST'] << value  
			end
		}
	}

    if (lwmtx)
            lwmtxlist = File.new("lwmtxlist.txt", "r")

            #UID: 0xXXXXXXXX - Workarea: 0xYYYYYYYY - Name: ZZZZZZZZ
            regexpEntry = /^UID: .+ - Workarea: (0x.+) - Name: .+$/

            while (line = lwmtxlist.gets)
                line.chomp!
                if (line.match(regexpEntry)) 
                    line.scan(regexpEntry) { |addr|
                         config_values["LWMUTEX_ADDR_LIST"].push(addr)
                    }
                end
            end
    end
elsif (File.exists?("exploit_config.h") && File.exists?("sdk.S"))
	IO.read("exploit_config.h") \
		.gsub(/\\\n/, "") \
		.gsub(/\/\*.+?\*\//m, "\s") \
		.each_line { |line|
		line.slice!(/\/\/.*$/)
		line.scan(/^\s*#\s*define\s+(.+?)\s+(.+)\s*$/) { |key, str|
			if str
				if str =~ /^{\s*(.+?)\s*}$/
					if config_values[key]
						$1.split(/\s*,\s*/).each { |element|
							config_values[key] << element
						}
					end
				else
					config_values[key] = str
				end
			else
				config_values[key] = true
			end
		}
	}
	IO.foreach("sdk.S") { |line|
		#	AddNID sceIoLseek, 0x08A885D0
		line.scan(/^\sAddNID (.+), (.+)$/) { |name, addr|
			nids << [name.to_nid, addr]
		}
	}
else
    help
    abort
end

if (config_values["TH_ADDR_LIST"].empty? &&
	config_values["ALARM_ADDR_LIST"].empty? &&
	config_values["LWMUTEX_ADDR_LIST"].empty? &&
	config_values["EV_ADDR_LIST"].empty? &&
	config_values["SEMA_ADDR_LIST"].empty? &&
	config_values["GAME_FREEMEM_ADDR"].empty? &&
	nids.empty?)
	puts "!!!! ERROR, NO DATA FOUND! MAKE SURE THAT uidlist.txt IS IN UNIX FORMAT!!!"
	abort
end

# HBL stubs
Config = [
	{
		:lib => "InterruptManager",
		:functions => [
			[0xD61E6961, "sceKernelReleaseSubIntrHandler"],
		],
	},
	{
		:lib => "IoFileMgrForUser",
		:functions => [
			[0x55F4717D, "sceIoChdir"],
			[0x810c4bc3, "sceIoClose"],
			[0xEB092469, "sceIoDclose"],
			[0xB29DDF9C, "sceIoDopen"],
			[0xE3EB004C, "sceIoDread"],
			[0x27EB27B8, "sceIoLseek"],
			[0x109f50bc, "sceIoOpen"],
			[0x6A638D83, "sceIoRead"],
			[0x42ec03ac, "sceIoWrite"],
		],
	},
	{
		:lib => "ModuleMgrForUser",
		:functions => [
			[0x8F2DF740, "ModuleMgrForUser_8F2DF740"], #sceKernelSelfStopUnloadModuleWithStatus, see hook.c
			[0xD8B73127, "sceKernelGetModuleIdByAddress"],
			[0x644395E2, "sceKernelGetModuleIdList"],
			[0x977DE386, "sceKernelLoadModule"],
			[0xD1FF982A, "sceKernelStopModule"],
			[0x2E0911AA, "sceKernelUnloadModule"],
		],
	},
	{
		:lib => "UtilsForUser",
		:functions => [
			# only one of sceKernelDcacheWritebackInvalidateAll and sceKernelDcacheWritebackAll is used, it depends on the exploit,
            [0xB435DEC5, "sceKernelDcacheWritebackInvalidateAll"],
			[0x79D1C3FA, "sceKernelDcacheWritebackAll"],
            [0x3EE30821, "sceKernelDcacheWritebackRange"],
            [0x34B9FA9E, "sceKernelDcacheWritebackInvalidateRange"],
        ],
    }  ,  
    { 
        :lib => "ThreadManForUser",
        :functions => [ 
            [0xCEADEB47, "sceKernelDelayThread"],
            [0xF475845D, "sceKernelStartThread"],
            [0x446D8DE6, "sceKernelCreateThread"], 
            [0x616403BA, "sceKernelTerminateThread"], 
            [0x383F7BCC, "sceKernelTerminateDeleteThread"], 
            [0x809CE29B, "sceKernelExitDeleteThread"],
            [0x9FA03CD3, "sceKernelDeleteThread"], 
            [0x28B6489C, "sceKernelDeleteSema"],
            [0x60107536, "sceKernelDeleteLwMutex"],
            [0xED1410E0, "sceKernelDeleteFpl"],
            [0x89B3D48C, "sceKernelDeleteVpl"],
            [0xef9e4c70, "sceKernelDeleteEventFlag"], 
            [0x7E65B999, "sceKernelCancelAlarm"],
            [0xAA73C935, "sceKernelExitThread"],
            [0x68DA9E36, "sceKernelDelayThreadCB"],
            [0x82826F70, "sceKernelSleepThreadCB"],            
            [0x876DBFAD, "sceKernelSendMsgPipe"],
            [0x74829B76, "sceKernelReceiveMsgPipe"],
            [0x884C9F90, "sceKernelTrySendMsgPipe"],
            [0xDF52098F, "sceKernelTryReceiveMsgPipe"],
            [0x293B45B8, "sceKernelGetThreadId"],
            [0xE81CAF8F, "sceKernelCreateCallback"],
            [0x3F53E640, "sceKernelSignalSema"],
            [0x4E3A1105, "sceKernelWaitSema"],
            [0xD6DA4BA1, "sceKernelCreateSema"],
            [0x977DE386, "sceKernelLoadModule"],  
            [0x9944F31F, "sceKernelSuspendThread"],
            [0x75156E8F, "sceKernelResumeThread"],
            [0x6D212BAC, "sceKernelWaitSemaCB"],            
        ],
    }   , 
    { 
        :lib => "LoadExecForUser",
        :functions => [
            [0x2AC9954B, "sceKernelExitGameWithStatus"],
            [0x05572A5F, "sceKernelExitGame"],   
            [0x4AC57943, "sceKernelRegisterExitCallback"],            
        ],
    },    
    { 
        :lib => "SysMemUserForUser",
        :functions => [
            [0x237DBD4F, "sceKernelAllocPartitionMemory"],
            [0x9D9A5BA1, "sceKernelGetBlockHeadAddr"],
            [0xB6D61D02, "sceKernelFreePartitionMemory"],
# The two following can be overriden by some of our code, which will not fail
# Our code is slow though, so if syscalls can be done 100% perfect at some point let's put those back
#            [0xF919F628, "sceKernelTotalFreeMemSize"],
#            [0xA291F107, "sceKernelMaxFreeMemSize"],
        ],
    },   
    { 
        :lib => "sceDisplay",
        :functions => [
            [0x289D82FE, "sceDisplaySetFrameBuf"],
            [0x984C27E7, "sceDisplayWaitVblankStart"],
            [0x46F186C3, "sceDisplayWaitVblankStartCB"],
        ],
    },  
    { 
        :lib => "sceCtrl",
        :functions => [
            [0x1F803938, "sceCtrlReadBufferPositive"],
            [0x3A622550, "sceCtrlPeekBufferPositive"],
        ],
    },
    {
    	:lib => "sceAudio",
    	:functions => [
    		[0x6FC46853, "sceAudioChRelease"],
            [0xB011922F, "sceAudioGetChannelRestLength"],
            [0x136CAF51, "sceAudioOutputBlocking"],
            [0x13F592BC, "sceAudioOutputPannedBlocking"],
            [0x5EC81C55, "sceAudioChReserve"],
            [0x5C37C0AE, "sceAudioSRCChRelease"],
    	],
    },  
    {
    	:lib => "sceRtc",
    	:functions => [
    		[0xE7C27D1B, "sceRtcGetCurrentClockLocalTime"],
    	],
    }, 
    {
    	:lib => "scePower",
    	:functions => [
			[0x469989AD, "scePower_469989AD"], # == scePowerSetClockFrequency see hook.c
    		[0xEBD177D6, "scePower_EBD177D6"], # == scePowerSetClockFrequency see hook.c
    	],
    },     
   	{
    	:lib => "sceUtility",
    	:functions => [
            [0x2A2B3DE0, "sceUtilityLoadModule"],
            [0x1579A159, "sceUtilityLoadNetModule"],
            [0x0D5BC6D2, "sceUtilityLoadUsbModule"],
            [0xC629AF26, "sceUtilityLoadAvModule"],
            [0xE49BFE92, "sceUtilityUnloadModule"],
            [0x64D50C56, "sceUtilityUnloadNetModule"],
            [0xF64910F0, "sceUtilityUnloadUsbModule"],
            [0xF7D8D092, "sceUtilityUnloadAvModule"],
    	],
    },  
   	{
    	:lib => "sceGe_user",
    	:functions => [
    		[0x1F6752AD, "sceGeEdramGetSize"],
    		[0xE47E40E4, "sceGeEdramGetAddr"],
    	],
    }
]


hooks = Array.new;

CantDelete = {
    "sceIoDread" => 1,
    "sceIoDopen" => 1,
    "sceIoDclose" => 1,
    "scePower_EBD177D6" => !nids.assoc("scePower_469989AD".to_nid), # TODO handle power functions properly
    "sceKernelGetModuleIdByAddress" => 1, 
    "sceKernelCancelAlarm" => !(config_values["ALARM_ADDR_LIST"].empty?), 
    "sceKernelDcacheWritebackAll" => !nids.assoc("sceKernelDcacheWritebackRange".to_nid),
    "sceKernelDeleteLwMutex" => !(config_values["LWMUTEX_ADDR_LIST"].empty?),
    "sceKernelDeleteEventFlag" => !(config_values["EV_ADDR_LIST"].empty?),
    "sceKernelFreePartitionMemory" => 1,
    "sceKernelDeleteVpl" =>  !(config_values["VPL_ADDR_LIST"].empty?), 
    "sceKernelDeleteFpl" =>  !(config_values["FPL_ADDR_LIST"].empty?),
    "sceKernelDelayThread" => 1,
    "sceKernelDeleteThread" => 1,
    "sceKernelSleepThreadCB" => !nids.assoc("sceKernelDelayThreadCB".to_nid),
    "sceKernelTerminateThread" => !nids.assoc("sceKernelTerminateDeleteThread".to_nid),
	"sceKernelGetThreadId" => 1,
	"sceKernelCreateSema" => 1,
    "sceAudioSRCChRelease" => 1
}
#no Solution for those now :(


def deleteConfig(name)
    puts("Removing #{name}");
    if (CantDelete[name]) then
        puts("HBL needs #{name} so we're Keeping it, but it seems your game does not import it.");
        return false;
    else
        Config.each {|libinfo | 
            libinfo[:functions].delete_if {|x| x[1] == name }
        }
        Config.delete_if{ |x| x[:functions].size == 0 }
        return true;
    end
end

if (config_values["ALARM_ADDR_LIST"].empty?) then
    deleteConfig("sceKernelCancelAlarm")
end

if (config_values["LWMUTEX_ADDR_LIST"].empty?) then
    deleteConfig("sceKernelDeleteLwMutex")
end

if (config_values["EV_ADDR_LIST"].empty?) then
    deleteConfig("sceKernelDeleteEventFlag")
end

if (config_values["GAME_FREEMEM_ADDR"].empty?) then
    deleteConfig("sceKernelFreePartitionMemory")
end

if (config_values["VPL_ADDR_LIST"].empty?) then
	deleteConfig("sceKernelDeleteVpl")
end

if (config_values["FPL_ADDR_LIST"].empty?) then
	deleteConfig("sceKernelDeleteFpl")
end

if (!nids.assoc("sceKernelDeleteThread".to_nid) && nids.assoc("sceKernelTerminateDeleteThread".to_nid)) then
	deleteConfig("sceKernelTerminateThread")
end

#
# Defines a bunch of common hooks
# We also filter out the imports that are not needed. We need to end up with 64 or less of them
#
if (!nids.assoc("sceKernelWaitSema".to_nid) && nids.assoc("sceKernelWaitSemaCB".to_nid)) then
	hooks.push(
"// define if your exploit does not have access to sceKernelWaitSema
#undef WAIT_SEMA
#define WAIT_SEMA sceKernelWaitSemaCB
");
end

if (!nids.assoc("sceGeEdramGetSize".to_nid))
	hooks.push(
"// Define if your exploit does not have access to  sceGeEdramGetSize
// You will see a linker message in the form:
//  undefined reference to `sceGeEdramGetSize'
#define FORCE_HARDCODED_VRAM_SIZE
")
    deleteConfig("sceGeEdramGetSize")
end

if (!nids.assoc("sceUtilityLoadModule".to_nid) &&
    (nids.assoc("sceUtilityLoadNetModule".to_nid) ||
     nids.assoc("sceUtilityLoadUsbModule".to_nid) ||
     nids.assoc("sceUtilityLoadAvModule".to_nid)))
    hooks.push("#define USE_EACH_UTILITY_MODULE_LOAD_FUNCTION
")
    if (nids.assoc("sceUtilityLoadNetModule".to_nid))
        hooks.push("#define USE_NET_MODULE_LOAD_FUNCTION
")
    end
    if (nids.assoc("sceUtilityLoadUsbModule".to_nid))
        hooks.push("#define USE_USB_MODULE_LOAD_FUNCTION
")
    end
    if (nids.assoc("sceUtilityLoadAvModule".to_nid))
        hooks.push("#define USE_AV_MODULE_LOAD_FUNCTION
")
    end
else
    deleteConfig("sceUtilityLoadNetModule")
    deleteConfig("sceUtilityLoadUsbModule")
    deleteConfig("sceUtilityLoadAvModule")
end

if (!nids.assoc("sceUtilityUnloadModule".to_nid))
    if (nids.assoc("sceUtilityUnloadNetModule".to_nid) ||
        nids.assoc("sceUtilityUnloadUsbModule".to_nid) ||
        nids.assoc("sceUtilityUnloadAvModule".to_nid))
        hooks.push("#define USE_EACH_UTILITY_MODULE_UNLOAD_FUNCTION
")
        if (nids.assoc("sceUtilityUnloadNetModule".to_nid))
            hooks.push("#define USE_NET_MODULE_UNLOAD_FUNCTION
")
        end
        if (nids.assoc("sceUtilityUnloadUsbModule".to_nid))
            hooks.push("#define USE_USB_MODULE_UNLOAD_FUNCTION
")
        end
        if (nids.assoc("sceUtilityUnloadAvModule".to_nid))
            hooks.push("#define USE_AV_MODULE_UNLOAD_FUNCTION
")
        end
    else
        hooks.push("#define DISABLE_UNLOAD_UTILITY_MODULES
")
    end
else
    deleteConfig("sceUtilityUnloadNetModule")
    deleteConfig("sceUtilityUnloadUsbModule")
    deleteConfig("sceUtilityUnloadAvModule")
end

if (!nids.assoc("sceUtilityCheckNetParam".to_nid)) 
	hooks.push(
"// Failing calls to sceUtilityCheckNetParam will probably deactivate net access
#define HOOK_ERROR_sceUtilityCheckNetParam
");
end

if (!nids.assoc("sceRtcGetCurrentTick".to_nid) && nids.assoc("sceRtcGetCurrentClockLocalTime".to_nid)) then
	hooks.push(
"#define HOOK_sceRtcGetCurrentTick
"); 
end

hook_if_not_exist = [
	"sceKernelGetThreadId",
	"sceKernelTotalFreeMemSize",
	"sceKernelLoadModule",
];

hook_if_not_exist.each { |v| 
	if (!nids.assoc(v.to_nid)) then
		hooks.push("#define HOOK_#{v}\n");
		deleteConfig(v);
	end
}


a_WITH_b_hooks ={
	"sceAudioGetChannelRestLen" => "sceAudioGetChannelRestLength",
	"sceAudioOutput" => "sceAudioOutputBlocking",
    "sceAudioOutput2GetRestSample" => "sceAudioGetChannelRestLength",
    "sceAudioOutputBlocking" => "sceAudioOutputPannedBlocking",
    "sceAudioOutputPanned" => "sceAudioOutputPannedBlocking",

    "sceCtrlPeekBufferPositive" => "sceCtrlReadBufferPositive",
    "sceCtrlReadBufferPositive" => "sceCtrlPeekBufferPositive",    

    "sceDisplayWaitVblankStart" => "sceDisplayWaitVblankStartCB",
    "sceDisplayWaitVblankStart" => "sceKernelDelayThread",
    "sceDisplayWaitVblankStartCB" => "sceDisplayWaitVblankStart" ,  

    "sceKernelDcacheWritebackInvalidateAll" => "sceKernelDcacheWritebackInvalidateRange",
    "sceKernelDcacheWritebackInvalidateAll" => "sceKernelDcacheWritebackAll",
    "sceKernelDcacheWritebackAll" => "sceKernelDcacheWritebackRange",     
    "sceKernelExitGame" => "sceKernelExitGameWithStatus",
    "sceKernelReceiveMsgPipe" => "sceKernelTryReceiveMsgPipe",
    "sceKernelTryReceiveMsgPipe" => "sceKernelReceiveMsgPipe",
    "sceKernelSelfStopUnloadModule" => "ModuleMgrForUser_8F2DF740",
    "sceKernelSleepThreadCB" => "sceKernelDelayThreadCB",
    "sceKernelTerminateThread" => "sceKernelTerminateDeleteThread",
    "sceKernelWaitSema" =>  "sceKernelWaitSemaCB",

    "scePowerSetClockFrequency" => "scePower_EBD177D6",

    "sceRtcGetCurrentClock" => "sceRtcGetCurrentClockLocalTime",



    # Dummy: need real functions
    "sceKernelChangeCurrentThreadAttr" => "dummy",
    "sceCtrlSetIdleCancelThreshold"  => "dummy",
    "sceImposeSetHomePopup"   => "dummy",
    "sceKernelReferThreadStatus" => "dummy",
    "sceKernelWakeupThread" => "dummy",
    "sceDisplayGetVcount" => "dummy",
    "sceKernelDeleteSema" => "dummy",
    "sceKernelVolatileMemUnlock" => "dummy"
};

delete_b_if_a_exists ={
	"sceCtrlPeekBufferPositive" => "sceCtrlReadBufferPositive",

	"sceKernelDcacheWritebackInvalidateAll" => "sceKernelDcacheWritebackInvalidateRange",
	"sceKernelDcacheWritebackAll" => "sceKernelDcacheWritebackRange",
	"sceKernelExitGame" => "sceKernelExitGameWithStatus",
	"sceKernelWaitSema" =>  "sceKernelWaitSemaCB",
};

a_WITH_b_hooks.each { |k, v| 
	if (!nids.assoc(k.to_nid) && (nids.assoc(v.to_nid) || v == "dummy")) then
		hooks.push("#define HOOK_#{k}_WITH_#{v}\n");
		#deleteConfig(k);
	end
}

delete_b_if_a_exists.each { |k, v| 
	if (nids.assoc(k.to_nid)) then
		deleteConfig(v);
	end
}

if (!nids.assoc("sceIoChdir".to_nid))
	hooks.push(
"// if sceIoCHDIR crashes, don't call it, at all
#define CHDIR_CRASH
");
	deleteConfig("sceIoChdir")
end

if (!nids.assoc("sceKernelUtilsMt19937Init".to_nid) || !nids.assoc("sceKernelUtilsMt19937UInt".to_nid))
	hooks.push("
#define HOOK_mersenne_twister_rdm
");  
end

nb_nids = 0;
nids_offset = 0;
Config.each {|libinfo | 
	nb_nids = nb_nids + libinfo[:functions].size
	nids_offset = nids_offset + libinfo[:lib].size + 1 + 3 * 4
}

# Delete functions that are not defined. This will yield compilation error if needed,
# This is the best way to avoid runtime issues if syscall estimation is not working
Config.each {|libinfo |
	libinfo[:functions].each{|function|
		if (!nids.assoc(function[1].to_nid)) then
			if (deleteConfig(function[1])) then
				nb_nids -= 1;
			end
		end
	}
}



# Handle threads in a somewhat magical way
if ((!nids.assoc("sceKernelTerminateThread".to_nid) || !nids.assoc("sceKernelDeleteThread")) && (!nids.assoc("sceKernelTerminateDeleteThread".to_nid))) then
	if (nids.assoc("sceKernelSuspendThread".to_nid) && nids.assoc("sceKernelExitDeleteThread".to_nid) && nids.assoc("sceKernelResumeThread".to_nid))     then
		hooks.push(
"// Alternate solution to handle threads (experimental)
//#define SUSPEND_THEN_DELETE_THREADS
");
	else
		puts("ERROR, No thread handling function, most likely you won't be able to port HBL to this game")
	end
else
	deleteConfig("sceKernelSuspendThread")
	deleteConfig("sceKernelResumeThread")
end

if (!net_util) then
	hooks.push(
"// Avoid loading NET, USB and NP utilities if the game doesn't import them (required since firmware 3.00)
#define HOOK_UTILITY
#define AVOID_NET_UTILITY
");
end

a_WITH_b_hooks.each { |k, v| 
	if (!nids.assoc(k) && (nids.assoc(v) || v == "dummy".to_nid)) then
		if (deleteConfig(k)) then
			nb_nids -= 1;
		end
	end
}

nb_nids = 0;
nids_offset = 0;
Config.each {|libinfo |
	nb_nids = nb_nids + libinfo[:functions].size
	nids_offset = nids_offset + libinfo[:lib].size + 1 + 3 * 4
}

if (nb_nids > max_nids) then
	puts "TOO MANY NIDS";
	exit;
end

# Write new loader.h
curr_addr = call_address #0x10000; #0x0880FF00 # 0x00013F00
output_folder = "output"
Dir.mkdir(output_folder) unless File.directory?(output_folder);
out_loader_h = File.new( output_folder + "/loader.h", "w");
out_loader_h.binmode;
out_loader_h.print %Q[/* This file was automatically generated by gen_exploit_config.rb */
#ifndef ELOADER_LOADER
#define ELOADER_LOADER

#include <hbl/modmgr/elf.h>

static const tStubEntry hbl_stub_entires[] = {
	]

out = File.new( output_folder + "/sdk_hbl.S", "w")
out.binmode();

out.puts %Q[# This file was automatically generated by eLoaderconf.rb
# If you want to edit this file, edit eLoaderconf.rb instead
.macro AddNID funcname, offset

	.globl	\\funcname
	.ent	\\funcname
	.type	\\funcname, @function
\\funcname = \\offset
#\\funcname:
#	lui $v0, 0x1		# Put 0x10000 in $v0, $v0 is return value so there's no need to back it up
#	lw $v0, 0x18 ($v0)	# Get HBL stubs address, see eloader.c or loader.c for more info
#	addi $v0, $v0, \\offset	# Add offset
#	jr $v0			# Jump to stub
#	nop			# Leave this delay slot empty!
	.end	\\funcname
	.size	\\funcname, 8

.endm

	.text
	.align	2

]

Config.each {|libinfo | 
	if (curr_addr != call_address)
		out_loader_h.print ', '
	end
	out_loader_h.print(%Q[{
		.lib_name = "] + libinfo[:lib] + %Q[",
		.import_flags = 0,
		.lib_ver = 0x4001,
		.import_stubs = 5,
		.stub_size = ] + libinfo[:functions].size.to_s + %Q[,
		.nid_p = (int []){])
	jump_p = curr_addr
	i = 0

	out.puts("\n# " + libinfo[:lib] + '(' + libinfo[:functions].size.to_s + ')')

	max = 0
	libinfo[:functions].each {|nidinfo|
		if nidinfo[1].size > max then max = nidinfo[1].size end
	}

	libinfo[:functions].each {|nidinfo|
		out_loader_h.print((i == 0 ? "\n\t\t\t" : ', ') +'0x' + nidinfo[0].to_s(16).rjust(4, "0"))
		i = i < 3 ? i + 1 : 0
		out.puts("\tAddNID #{nidinfo[1]}, 0x" +  curr_addr.to_s(16).rjust(4, "0") + ' ' * (max - nidinfo[1].size) + ' # 0x' + nidinfo[0].to_s(16))
		curr_addr += 8
	}
	out_loader_h.print(%Q[
		},
		.jump_p = (void *)0x] + jump_p.to_s(16).rjust(4, '0') + %Q[
	}])
}

out_loader_h.puts %Q[
};

#endif
]

out.puts %Q[
	.ident "HBL-SDK"
]

out.close


out = File.new( output_folder + "/exploit_config.h", "w")

out.puts %Q[// This is a pregenerated file made by gen_exploit_config.rb. Some sections are labelled as "TODO", you need to enter your values here

#ifndef EXPLOIT_CONFIG
#define EXPLOIT_CONFIG

//Where to load hbl.bin in Ram
// Has to be a place not occupied by the game
// a correct address can be found in psplink, by typing:
// malloc 2 test l 204800
// (the value you want is head address, try h instead of lto get a different address if needed
// Ideally, it should be either smaller than 0x08900000 or higher then 0x09000000.
// If you don't have any address in these areas, you can use GAME_PRELOAD_FREEMEM, which can free some memory *before* you load HBL, and maybe free some useful ranges
#define HBL_LOAD_ADDR TODO
]

out.puts(%Q[

// HBL stubs size
#define HBL_STUBS_NUM ] + nb_nids.to_s)

out.puts %Q[
// To get the correct values for TH_ADDR_LIST, ALARM_ADDR_LIST, LWMUTEX_ADDR_LIST, EV_ADDR_LIST, SEMA_ADDR_LIST, GAME_FREEMEM_ADDR,
// the best is to use freemem.rb in the tools folder.
// otherwise you can gather these values with psplink

// Addresses where the threads to delete are defined
// can be found with psplink (thlist)
]

out.puts("#define TH_ADDR_LIST { " + config_values["TH_ADDR_LIST"].join(", ")  + " }");

out.puts %Q[
//Addresses where the alarms to delete can be found
//psplink uidlist
]
if (config_values["ALARM_ADDR_LIST"].size() == 0)
    out << "//"
end
out.puts("#define ALARM_ADDR_LIST { " + config_values["ALARM_ADDR_LIST"].join(", ")  + " }");

out.puts %Q[
//Addresses where the workarea of the lwmutexes to delete can be found
//You need PSPLink Mod by 173210
//psplink lwmutexlist
]
if (config_values["LWMUTEX_ADDR_LIST"].size() == 0)
    out << "//"
end
out.puts("#define LWMUTEX_ADDR_LIST { " + config_values["LWMUTEX_ADDR_LIST"].join(", ")  + " }");

out.puts %Q[
//Addresses where the event flags to delete can be found
//psplink evlist
]
if (config_values["EV_ADDR_LIST"].size() == 0)
	out << "//"
end
out.puts("#define EV_ADDR_LIST { " + config_values["EV_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
//Addresses where the semaphores to delete can be found
//psplink smlist
}
if (config_values["SEMA_ADDR_LIST"].size() == 0)
	out << "//"
end
out.puts("#define SEMA_ADDR_LIST { " + config_values["SEMA_ADDR_LIST"].join(", ")  + " }");

if (config_values["VPL_ADDR_LIST"].size() == 0)
	out << "//"
end
out.puts("#define VPL_ADDR_LIST { " + config_values["VPL_ADDR_LIST"].join(", ")  + " }");

if (config_values["FPL_ADDR_LIST"].size() == 0)
	out << "//"
end

out.puts("#define FPL_ADDR_LIST { " + config_values["FPL_ADDR_LIST"].join(", ")  + " }");

out.puts %Q{
// Define to Free the game module (e.g. minna no golf)
// Not all games need that
}
if (config_values["GAME_FREEMEM_ADDR"].size() == 0)
	out << "//"
end
out.puts("#define GAME_FREEMEM_ADDR { " + config_values["GAME_FREEMEM_ADDR"].join(", ")  + " }");

out.puts %Q{
// Replace the "TODO" below with the code of your game (e.g UCUS12345)
#define HBL_ROOT "ms0:/PSP/SAVEDATA/TODO/"

// Some hooks are not really wise if the game already imports them. Files generated by gen_cfg_exploit try to define hooks
//cleverly based on the game imports, but at runtime additional stubs might be found that make these hooks obsolete.
// This define will prevent some of your hooks from being active, because HBL will decide at runtime that it is not a good idea to do the override
#define DONT_HOOK_IF_FUNCTION_IS_IMPORTED

// Define to free additional modules (net modules, etc...) (e.g. patapon2 demo)
// Not all games need that
#define UNLOAD_ADDITIONAL_MODULES

//There is in general no good reason to comment that one
//It searches for additional syscalls.
#define LOAD_MODULES_FOR_SYSCALLS
}

if (nids.assoc("sceKernelReleaseSubIntrHandler".to_nid)) 
	out.puts %Q{
#define SUB_INTR_HANDLER_CLEANUP
}
end

out.puts %Q{
// Hooks (function overrides/replacements)
}

out.puts(hooks.join("\n"));

out.puts %Q{
// Perfect syscall code: not available anymore in 6.60, so everything here is empty

// For which firmware versions is perfect syscall estimation available?
#define SYSCALLS_KNOWN_FW {  }
#define SYSCALLS_KNOWN_GO_FW { }

// Reference library for syscall estimation, all syscalls for this library must be known
#define SYSCALL_REF_LIB "sceOpenPSID"

// Syscall offsets, must be defined for all firmwares in SYSCALLS_KNOWN_FW
//#define SYSCALL_OFFSETS_500     {  }
//#define SYSCALL_OFFSETS_500_CFW {  }

//#define SYSCALL_OFFSETS_550     {  }
//#define SYSCALL_OFFSETS_550_CFW {  }

//#define SYSCALL_OFFSETS_570    {  }
//#define SYSCALL_OFFSETS_570_GO {  }

//#define SYSCALL_OFFSETS_600    {  }
//#define SYSCALL_OFFSETS_600_GO {  }


// Kernel memory dump offsets for the PSP GO
//#define SYSCALL_KERNEL_OFFSETS_620 {  }
//#define SYSCALL_KERNEL_OFFSETS_630 { } // Not available
//#define SYSCALL_KERNEL_OFFSETS_635 { } // Not available

#endif

}
